### Alle durchgefÃ¼hrten Anfragen

Firestore-Queries.txt Datei der Gruppe 05 mit der Datenbank Firestore und dem Projektteam:
Peter Fischer - 2210654
Leonelle Tifani Kommegne Kammegne - 2209740
Michael Mertl - 2209076
Gregor Pfister - 2209779
Jana Sophie Schweizer - 2209427

Nachfolgend sind die Abfragen fÃ¼r die einzelnen Aufgaben der Semesteraufgabe aufgelistet. Dabei wird zuerst die von
uns gebaute Funktion fÃ¼r die jeweilige Aufgabe aufgezeigt und direkt im Anschluss jeweils die konkreten Ausgaben
bei AusfÃ¼hrung der Funktion.

#### Aufgabe 4: Read Queries:
async function aufgabe4() {
    console.log('ğŸ“– Aufgabe 4: Read Queries\n');

    /**
     * Man kÃ¶nnte jede Collection bzw. ihre Sub-Collections hier vorladen und in den Abfragen nutzen.
     * Wir machen das aber nicht so, weil wir die Teilaufgaben jeweils einzeln betrachten wollen, um
     * die einzelnen nÃ¶tigen Schritte jeweils zu verdeutlichen.
    */

    // a) alle Orte, an denen Kurse durchgefÃ¼hrt werden
    /**
     * @old-relational-table Angebot
     * @collections angebote
     *
     * @logic
     * ğŸ”¸ In SQL:
     *     SELECT DISTINCT Ort FROM Angebot;
     *  ğŸ”¹ In Firestore:
     *     Alle Angebote abfragen und die Orte in einem Set speichern (um Duplikate zu vermeiden).
     *
     * @difference-to-sql
     *  Firestore unterstÃ¼tzt keine DISTINCT-Abfrage, daher muss manuell ein Set verwendet werden,
     *  um Duplikate zu entfernen.
     */
    const angeboteSnapshot = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    const orte = new Set(angeboteSnapshot.docs.map(a => a.data().Ort));
    console.log('ğŸ“ Orte:', [...orte]);

    // b) die Teilnehmer aus Augsburg
    /**
     * @old-relational-table Teilnehmer
     * @collections teilnehmer
     *
     * @logic
     *  ğŸ”¸ In SQL:
     *      SELECT * FROM Teilnehmer WHERE Ort = 'Augsburg';
     *  ğŸ”¹ In Firestore:
     *    Alle Teilnehmer mit Ort = 'Augsburg' abfragen.
     *
     * @difference-to-sql
     *  Firestore unterstÃ¼tzt WHERE-Filter, daher ist die Abfrage sehr Ã¤hnlich.
     */
    const teilnehmerAusAugsburg = await db.collection('teilnehmer').withConverter(createConverter<Teilnehmer>())
        .where('Ort', '==', 'Augsburg').get();
    console.log('\nğŸ‘¥ Teilnehmer aus Augsburg:');
    teilnehmerAusAugsburg.forEach(t => console.log(`- ${t.data().Name}`));

    // c) die Kursleiter mit einem Gehalt zwischen 3000 â‚¬ und 4000 â‚¬, sortiert nach Namen
    /**
     * @old-relational-table Kursleiter
     * @collections kursleiter
     *
     * @logic
     *  ğŸ”¸ In SQL:
     *      SELECT * FROM Kursleiter WHERE Gehalt BETWEEN 3000 AND 4000 ORDER BY Name;
     *  ğŸ”¹ In Firestore:
     *      Alle Kursleiter mit Gehalt >= 3000 und <= 4000 abfragen und nach Name sortieren.
     *
     * @difference-to-sql
     *  Sehr identisch, da Firestore auch WHERE und ORDER BY unterstÃ¼tzt.
     */
    const kursleiterSnapshot = await db.collection('kursleiter').withConverter(createConverter<Kursleiter>())
        .where('Gehalt', '>=', 3000).where('Gehalt', '<=', 4000).orderBy('Name').get();
    console.log('\nğŸ‘©â€ğŸ« Kursleiter (Gehalt 3000â‚¬-4000â‚¬):');
    kursleiterSnapshot.forEach(k => console.log(`- ${k.data().Name}: ${k.data().Gehalt}â‚¬`));

    // d) die Kurstitel mit Datum und Ort, an dem sie stattfinden
    /**
     * @old-relational-table Angebot, Kurs
     * @collections angebote
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT k.Titel, a.Datum, a.Ort
     *   FROM Angebot a JOIN Kurs k ON a.KursNr = k.KursNr;
     *
     * ğŸ”¹ In Firestore:
     *   - Alle Dokumente aus der Collection 'angebote' lesen
     *   - FÃ¼r jedes Angebot die gefragten Informationen ausgeben
     *   - Datum (Timestamp) wird per .toDate().toLocaleDateString() in lesbares Format umgewandelt
     *   - Ausgabe: angebot.KursTitel, angebot.Datum, angebot.Ort
     *
     * @difference-to-sql
     *   In SQL erfolgt die VerknÃ¼pfung Ã¼ber JOIN automatisch in einer Abfrage.
     *   In Firestore haben wir durch die Redundanz in der Collection 'angebote' die KursTitel
     *   bereits im Angebot gespeichert (Vorteil unserer Datenstruktur).
     */
    const angeboteSnapshot1 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    console.log('\nğŸ“š Kurstitel mit Datum und Ort:');
    for (const angebotDoc of angeboteSnapshot1.docs) {
        console.log(`- ${angebotDoc.data()?.KursTitel}: ${angebotDoc.data().Datum.toDate().toLocaleDateString()} in ${angebotDoc.data().Ort}`);
    }

    // e) Anfrage d) mit zusÃ¤tzlicher Ausgabe der Kursleiter
    /**
     * @old-relational-table Angebot, Kurs, Fuehrt_durch, Kursleiter
     * @collections angebote, angebote/{AngNr_KursNr}/kursleiter (Sub-Collection aus angebote)
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT k.Titel, a.Datum, a.Ort, l.Name
     *   FROM Angebot a
     *   JOIN Kurs k ON a.KursNr = k.KursNr
     *   JOIN Fuehrt_durch f ON f.AngNr = a.AngNr AND f.KursNr = a.KursNr
     *   JOIN Kursleiter l ON f.PersNr = l.PersNr;
     *
     * ğŸ”¹ In Firestore:
     *   - Alle Angebote aus 'angebote' laden
     *   - Kursleiter liegen als Sub-Collection unter dem Angebot: 'angebote/{AngNr_KursNr}/kursleiter'
     *
     * @difference-to-sql
     *   In SQL wird alles in einem JOIN abgebildet.
     *   In Firestore muss die zugehÃ¶rige Sub-Collection 'kursleiter' fÃ¼r jedes Angebot separat geladen werden.
     *   AuÃŸerdem haben wir durch die Redundanz in der Collection 'angebote' die KursTitel
     *   bereits im Angebot gespeichert (Vorteil unserer Datenstruktur).
     */
    console.log('\nğŸ“š Kurstitel mit Datum, Ort und Kursleiter:');
    const angeboteSnapshot2 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    for (const angebotDoc of angeboteSnapshot2.docs) {
        const angebotData = angebotDoc.data();
        const kursleiterSnap = await angebotDoc.ref.collection('kursleiter').withConverter(createConverter<Kursleiter>()).get();
        let kursleiterName = kursleiterSnap.docs.map(doc => doc.data().Name).join(', ');
        if (kursleiterName.length === 0) {
            console.warn(`âš ï¸ Kursleiter fÃ¼r Angebot ${angebotDoc.id} nicht gefunden.`);
            kursleiterName = 'Unbekannt';
            continue;
        }
        console.log(`- ${angebotData?.KursTitel}: ${angebotData?.Datum.toDate().toLocaleDateString()}, in ${angebotData?.Ort}, Kursleiter: ${kursleiterName}`);
    }

    // f) alle Kurstitel mit den Titeln der Kurse, die dafÃ¼r Voraussetzung sind. Hat ein Kurs keine Voraussetzungen,
    // so soll dieses Feld NULL sein. Achten Sie auf vernÃ¼nftige SpaltenÃ¼berschriften. Die Ausgabe soll nach Kursen
    // sortiert erfolgen
    /**
     * @old-relational-table Kurs, Vorauss
     * @collections kurse, kurse/{KursNr}/voraussetzungen (Sub-Collection aus Kurse)
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT k.Titel, v.VorNr
     *   FROM Kurs k
     *   LEFT JOIN Vorauss v ON k.KursNr = v.KursNr;

     * ğŸ”¹ In Firestore:
     *   - Alle Dokumente aus 'kurse' laden
     *   - FÃ¼r jeden Kurs: Sub-Collection 'voraussetzungen' abrufen
     *   - FÃ¼r jede Voraussetzung (v.id): den Kurs Ã¼ber 'kurse[v.id]' nachladen
     *   - Ausgabe: Titel des Kurses + Titel der Voraussetzungen

     * @difference-to-sql
     *   In SQL ist das ein einfacher LEFT JOIN.
     *   In Firestore:
     *     - Jede Voraussetzung fÃ¼r einen spezifischen Kurstitel muss separat gelesen werden (mehrere Reads)
     *     - Sub-Collections sind an Kurs gebunden â€“ globale Analyse erschwert
     *     - NULL-Werte mÃ¼ssen manuell ersetzt werden
     */
    console.log('\nğŸ“š Kurstitel mit Voraussetzungen:');
    console.log('Kurs\t\t\t Voraussetzungen');

    const kurseSnapshot = await db.collection('kurse')
        .withConverter(createConverter<Kurs>())
        .get();

    // Array fÃ¼r Ergebnisse
    const results: { kursTitel: string; voraussetzungen: string[] | null }[] = [];

    for (const kursDoc of kurseSnapshot.docs) {
        const kurs = kursDoc.data();
        const vorausSnap = await kursDoc.ref.collection('voraussetzungen').get();

        if (vorausSnap.empty) {
            results.push({
                kursTitel: kurs.Titel,
                voraussetzungen: null
            });
        } else {
            const vorausTitel = await Promise.all(
                vorausSnap.docs.map(async v => {
                    const vSnap = await db.collection('kurse').doc(v.id).withConverter(createConverter<Kurs>()).get();
                    return vSnap.exists ? vSnap.data()?.Titel ?? 'NULL' : 'NULL';
                })
            );

            results.push({
                kursTitel: kurs.Titel,
                voraussetzungen: vorausTitel
            });
        }
    }

    // Sortieren nach Kurs-Titel
    results.sort((a, b) => a.kursTitel.localeCompare(b.kursTitel));

    // Ausgabe
    for (const eintrag of results) {
        const vorausText = eintrag.voraussetzungen ? eintrag.voraussetzungen.join(', ') : 'NULL';
        console.log(`${eintrag.kursTitel.padEnd(25)}${vorausText}`);
    }

    // g) alle Teilnehmer, die einen Kurs am eigenen Wohnort gebucht haben
    /**
     * @old-relational-table Teilnehmer, Angebot, Nimmt_teil
     * @collections teilnehmer, teilnehmer/{TnNr}/teilnahmen, angebote
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT t.Name, a.Ort
     *   FROM Teilnehmer t
     *   JOIN Nimmt_teil nt ON t.TnNr = nt.TnNr
     *   JOIN Angebot a ON a.AngNr = nt.AngNr
     *   WHERE t.Ort = a.Ort;
     *
     * ğŸ”¹ In Firestore:
     *   - Alle Teilnehmer laden
     *   - FÃ¼r jeden Teilnehmer â†’ Sub-Collection teilnahmen lesen
     *   - FÃ¼r jede Teilnahme â†’ passendes Angebot per ID laden
     *   - Wohnort vom Teilnehmer mit Ort des Angebots vergleichen
     *   - Bei Ãœbereinstimmung ausgeben
     *
     * @difference-to-sql
     *   In SQL reicht ein einziger JOIN mit WHERE-Bedingung.
     *   In Firestore sind mehrere Reads notwendig: Teilnehmer â†’ Teilnahmen â†’ Angebot.
     */
    console.log('\nğŸ‘¥ Teilnehmer am eigenen Wohnort:');
    const teilnehmerSnapshot = await db.collection('teilnehmer').withConverter(createConverter<Teilnehmer>()).get();
    for (const tnDoc of teilnehmerSnapshot.docs) {
        const teilnehmer = tnDoc.data();
        const teilnahmenSnap = await tnDoc.ref.collection('teilnahmen').withConverter(createConverter<Teilnahme>()).get();
        for (const teilnahme of teilnahmenSnap.docs) {
            const { AngNr } = teilnahme.data();
            const angebot = await db.collection('angebote').doc(AngNr).withConverter(createConverter<Angebot>()).get();
            if (angebot.exists && angebot.data()?.Ort === teilnehmer.Ort) {
                console.log(`- ${teilnehmer.Name}: ${angebot.data()?.Ort}`);
            }
        }
    }

    // h) alle Kursangebote (Kurstitel und Angebotsnummer), zu denen es noch keine Teilnehmer gibt
    /**
     * @old-relational-table Angebot, Nimmt_teil, Teilnehmer
     * @collections angebote, teilnehmer/{TnNr}/teilnahmen (Sub-Collection aus teilnehmer)
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT * FROM Angebot a
     *   LEFT JOIN Nimmt_teil nt ON a.AngNr = nt.AngNr
     *   WHERE nt.TnNr IS NULL;
     *
     * ğŸ”¹ In Firestore:
     *   - Alle `teilnahmen` Ã¼ber Collection Group (`collectionGroup('teilnahmen')`) abrufen
     *   - Belegte `AngNr` in Set speichern
     *   - Alle `angebote` durchlaufen
     *   - Wenn `angebot.id` nicht im Set: Ausgabe
     *   - Titel Ã¼ber `kurse` via KursNr nachladen
     *
     * @difference-to-sql
     *   Firestore kennt kein LEFT JOIN â†’ manuelle Filterlogik
     *   `collectionGroup` erlaubt globale Abfrage Ã¼ber alle Teilnahmen
     *   (-> `collectionGroup` ist eine MÃ¶glichkeit alle Collections mit dem gleichen Namen zu durchsuchen)
     */
    console.log('\nğŸ“š Kursangebote ohne Teilnehmer:');
    const angeboteSnapshot3 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    const belegteAngebote = new Set<string>();

    // 1. Alle belegten Angebote Ã¼ber Collection Group Query holen
    const teilnahmenSnapshot = await db.collectionGroup('teilnahmen').withConverter(createConverter<Teilnahme>()).get();
    teilnahmenSnapshot.forEach(doc => belegteAngebote.add(doc.data().AngNr));

    // 2. Alle Angebote durchgehen, nur die ohne Teilnehmer ausgeben
    for (const angebotDoc of angeboteSnapshot3.docs) {
        if (!belegteAngebote.has(angebotDoc.id)) {
            const angebot = angebotDoc.data();
            const kurs = await db.collection('kurse').doc(angebot.KursNr).withConverter(createConverter<Kurs>()).get();
            const titel = kurs.exists ? kurs.data()?.Titel : angebot.KursNr;
            console.log(`- ${titel}, Angebot ${angebotDoc.id}`);
        }
    }

    // i) alle Kurse (egal welches Angebot) mit mindestens 2 Teilnehmern
    /**
     * @old-relational-table Nimmt_teil, Angebot, Kurs
     * @collections teilnehmer/{TnNr}/teilnahmen (Sub-Collection aus teilnehmer), angebote, kurse
     *
     * @logic
     * ğŸ”¸ In SQL:
     *   SELECT k.Titel, COUNT(*) AS Anzahl
     *   FROM Nimmt_teil nt
     *   JOIN Angebot a ON nt.AngNr = a.AngNr
     *   JOIN Kurs k ON a.KursNr = k.KursNr
     *   GROUP BY a.KursNr
     *   HAVING COUNT(*) >= 2;
     *
     * ğŸ”¹ In Firestore:
     *  - Alle `angebote` laden: Map<AngNr â†’ KursNr>
     *  - Alle `teilnahmen` Ã¼ber Collection Group Query (`collectionGroup('teilnahmen')`)
     *  - ZÃ¤hlung: KursNr â†’ Teilnehmeranzahl
     *  - Alle `kurse` laden: KursNr â†’ Titel
     *  - Ausgabe: Kurse mit mindestens 2 Teilnehmern
     *
     * @difference-to-sql
     *   Kein echtes GROUP BY â†’ Aggregation erfolgt clientseitig
     *   `collectionGroup` ermÃ¶glicht effiziente Abfrage aller Teilnahmen
     *   Aggregation mit einfachem ZÃ¤hlerobjekt auf KursNr-Ebene
     */
    console.log('\nğŸ“š Kurse mit mindestens 2 Teilnehmern (alle Angebote zusammengefasst):');

    // 1. Alle Angebote laden: Map<AngNr, KursNr>
    const angeboteSnapshot4 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    const angebotZuKurs = new Map<string, string>();
    for (const doc of angeboteSnapshot4.docs) {
        const { KursNr } = doc.data();
        angebotZuKurs.set(doc.id, KursNr);
    }

    // 2. Alle Teilnahmen Ã¼ber Collection Group Query laden
    const teilnahmenSnapshot1 = await db.collectionGroup('teilnahmen').withConverter(createConverter<Teilnahme>()).get();
    const kursTeilnehmerCounter: Record<string, number> = {};

    for (const teilnahme of teilnahmenSnapshot1.docs) {
        const { AngNr } = teilnahme.data();
        const kursNr = angebotZuKurs.get(AngNr);
        if (kursNr) kursTeilnehmerCounter[kursNr] = (kursTeilnehmerCounter[kursNr] || 0) + 1;
    }

    // 3. Alle Kurse laden: Map<KursNr, Titel>
    const kurseSnapshot1 = await db.collection('kurse').withConverter(createConverter<Kurs>()).get();
    const kursTitelMap = new Map<string, string>();
    for (const doc of kurseSnapshot1.docs) {
        kursTitelMap.set(doc.id, doc.data().Titel);
    }

    // 4. Ausgabe: Nur Kurse mit mindestens 2 Teilnehmern
    for (const [kursNr, anzahl] of Object.entries(kursTeilnehmerCounter)) {
        if (anzahl >= 2) {
            const titel = kursTitelMap.get(kursNr) ?? kursNr;
            console.log(`- ${titel}: ${anzahl} Teilnehmer`);
        }
    }

    // j) alle Meier, sowohl Teilnehmer als auch Kursleiter
    /**
     * @old-relational-table Teilnehmer, Kursleiter
     * @collections teilnehmer, Kursleiter
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *       SELECT * FROM Teilnehmer WHERE name LIKE '%Meier%' UNION SELECT * FROM Kursleiter
     *       WHERE name LIKE '%Meier%';
     *   ğŸ”¹ In Firestore:
     *       Zwei separate Abfragen:
     *          - teilnehmer: Name >= 'Meier' und Name <= 'Meier\uf8ff'
     *          - kursleiter: Name >= 'Meier' und Name <= 'Meier\uf8ff'
     *
     * @difference-to-sql
     *   In SQL kÃ¶nnen Daten aus mehreren Tabellen mit UNION kombiniert werden. In Firestore kann jede
     *   Read-Operation nur auf eine Collection angewendet werden, daher werden zwei separate Abfragen durchgefÃ¼hrt.
     */
    console.log('\nğŸ‘¥ Alle Meier:');
    const teilnehmerMeier = await db.collection('teilnehmer')
        .where('Name', '>=', 'Meier')
        .where('Name', '<=', 'Meier\uf8ff')
        .withConverter(createConverter<Teilnehmer>())
        .get();
    teilnehmerMeier.forEach(doc => console.log(`- Teilnehmer: ${doc.data().Name}`));
    const kursleiterMeier = await db.collection('kursleiter')
        .where('Name', '>=', 'Meier')
        .where('Name', '<=', 'Meier\uf8ff')
        .withConverter(createConverter<Kursleiter>())
        .get();
    kursleiterMeier.forEach(doc => console.log(`- Kursleiter: ${doc.data().Name}`));

    // k) die Kurstitel mit der jeweiligen Anzahl der Angebote
    /**
     * @old-relational-table Kurs, Angebot
     * @collections angebote, kurse
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *       SELECT k.titel, COUNT(a.id) AS angebote_count FROM Kurs k LEFT JOIN Angebot a ON k.KursNr = a.KursNr
     *       GROUP BY k.KursNr, k.Titel ORDER BY k.Titel;
     *   ğŸ”¹ In Firestore:
     *      - Alle `kurse` laden â†’ Map<KursNr â†’ Titel> + ZÃ¤hler auf 0
     *      - Alle `angebote` laden â†’ pro `KursNr` zÃ¤hlen
     *      - Ausgabe sortiert nach Titel
     *
     * @difference-to-sql
     *   Firestore unterstÃ¼tzt keine JOINs â†’ Titel manuell aus `kurse` laden
     *   Auch kein GROUP BY oder aggregiertes COUNT pro Gruppe
     *   `count()` von Firestore kann **nicht gruppieren** (nur Gesamtanzahl oder gefilterte Query zÃ¤hlen)
     *   Daher erfolgt Gruppierung und ZÃ¤hlung manuell per JavaScript (Map + Counter)
     */
    console.log('\nğŸ“š Kurstitel mit Anzahl der Angebote:');

    // Kurse laden
    let kursTitelMap1 = new Map<string, string>();
    const angeboteCounter = new Map<string, number>();

    const kurseSnapshot2 = await db.collection('kurse').withConverter(createConverter<Kurs>()).get();
    kurseSnapshot2.forEach(doc => {
        const kursNr = doc.id;
        const titel = doc.data().Titel;
        kursTitelMap1.set(kursNr, titel);
        angeboteCounter.set(kursNr, 0); // vorinitialisieren mit 0
    });

    // Angebote zÃ¤hlen
    const angeboteSnapshot5 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    angeboteSnapshot5.forEach(doc => {
        const { KursNr } = doc.data() as Angebot;
        if (angeboteCounter.has(KursNr)) {
            angeboteCounter.set(KursNr, (angeboteCounter.get(KursNr) ?? 0) + 1);
        } else {
            // falls es ein Angebot fÃ¼r einen Kurs gibt, der nicht mehr in 'kurse' existiert
            angeboteCounter.set(KursNr, 1);
            kursTitelMap1.set(KursNr, KursNr);
        }
    });

    // Ausgabe
    [...angeboteCounter.entries()]
        .sort(([a], [b]) => (kursTitelMap1.get(a) ?? a).localeCompare(kursTitelMap1.get(b) ?? b))
        .forEach(([kursNr, count]) => {
            const titel = kursTitelMap1.get(kursNr) ?? kursNr;
            console.log(`- ${titel}: ${count} Angebote`);
        });

    // l) die Kurstitel mit der Anzahl der Voraussetzungen, die mindestens 2 Voraussetzungen haben. Die Ausgabe
    // soll so erfolgen, dass die Kurse mit den meisten Voraussetzungen zuerst kommen
    /**
     * @old-relational-table Vorauss, Kurs
     * @collections kurse, kurse/{KursNr}/voraussetzungen (Sub-Collection aus Kurse)
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *       SELECT k.titel FROM Kurs k JOIN Vorauss v ON k.KursNr = v.KursNr GROUP BY k.KursNr,
     *       k.Titel HAVING COUNT(v.VorNr) >= 2;
     *   ğŸ”¹ In Firestore:
     *      - Alle `kurse` laden
     *      - FÃ¼r jeden Kurs: Sub-Collection `voraussetzungen` laden und zÃ¤hlen
     *      - Wenn Anzahl â‰¥ 2 â†’ Kurs aufnehmen
     *
     * @difference-to-sql
     *    Firestore kennt kein JOIN oder GROUP BY â†’ manuelle Verarbeitung nÃ¶tig
     *    `count()` auf Sub-Collections wÃ¤re nur in Server SDKs (z. B. Admin SDK) mÃ¶glich,
     *     spart aber kaum Aufwand, da die Sub-Collection ohnehin geladen werden muss
     */
    console.log('\nğŸ“šKurse mit mindestens 2 Voraussetzungen (absteigend sortiert):');
    const kurseMitVoraussetzungen: { titel: string; anzahl: number }[] = [];

    const kurseSnapshot3 = await db.collection('kurse').withConverter(createConverter<Kurs>()).get();
    for (const kursDoc of kurseSnapshot3.docs) {
        const titel = kursDoc.data().Titel;
        const vorausSnap = await kursDoc.ref.collection('voraussetzungen').get();

        if (vorausSnap.size >= 2) {
            kurseMitVoraussetzungen.push({
                titel,
                anzahl: vorausSnap.size
            });
        }
    }

    // Nach Anzahl absteigend sortieren
    kurseMitVoraussetzungen.sort((a, b) => b.anzahl - a.anzahl);

    // Ausgabe
    for (const kurs of kurseMitVoraussetzungen) {
        console.log(`- ${kurs.titel}: ${kurs.anzahl} Voraussetzungen`);
    }

    // m) fÃ¼r alle Kurse (Titel ausgeben) das durchschnittliche Gehalt der Kursleiter, die ein Angebot dieses
    // Kurses durchfÃ¼hren (nach diesem Durchschnitt aufsteigend sortiert)
    /**
     * @old-relational-table Kurs, Fuehrt_Durch, Kursleiter
     * @collections angebote, angebote/{PersNr}/kursleiter (Sub-Collection aus angebote)
     *
     * @logic
     *   ğŸ”¸ In SQL: SELECT k.Titel, AVG(kl.Gehalt) FROM Kurs k JOIN Fuehrt_Durch fd ON k.KursNr = fd.KursNr
     *   JOIN Kursleiter kl ON fd.PersNr = kl.PersNr GROUP BY k.KursNr, k.Titel;
     *   ğŸ”¹ In Firestore:
     *     - Alle `angebote` laden
     *      - Je Angebot: Sub-Collection `kursleiter` abrufen
     *      - FÃ¼r jede KursNr: GehÃ¤lter sammeln
     *      - Durchschnitt berechnen und sortieren
     *
     * @difference-to-sql
     *    Kein GROUP BY oder AVG in Firestore
     *    `average()` von Firestore ist aktuell nur auf flachen Collections ohne Gruppierung mÃ¶glich
     *    Aggregation daher manuell (Map<KursNr â†’ Gehaltsliste> + clientseitiges avg)
     */
    console.log('\nğŸ“š Durchschnittliches Gehalt der Kursleiter pro Kurs (aufsteigend):');

    const kursGehaelterMap = new Map<string, { titel: string; gehaelter: number[] }>();
    const angeboteSnapshot6 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();

    for (const angebot of angeboteSnapshot6.docs) {
        const { KursNr, KursTitel } = angebot.data();

        // Sub-Collection 'kursleiter' laden
        const kursleiterSnap = await angebot.ref.collection('kursleiter').withConverter(createConverter<Kursleiter>()).get();

        if (!kursGehaelterMap.has(KursNr)) {
            kursGehaelterMap.set(KursNr, { titel: KursTitel ?? KursNr, gehaelter: [] });
        }

        for (const leiter of kursleiterSnap.docs) {
            kursGehaelterMap.get(KursNr)?.gehaelter.push(leiter.data().Gehalt);
        }
    }

    // Ergebnisse berechnen
    const result: { titel: string; avg: number }[] = [];

    for (const { titel, gehaelter } of kursGehaelterMap.values()) {
        if (gehaelter.length === 0) continue;
        const avg = gehaelter.reduce((a, b) => a + b, 0) / gehaelter.length;
        result.push({ titel, avg });
    }

    // Aufsteigend sortieren
    result.sort((a, b) => a.avg - b.avg);

    // Ausgabe
    for (const { titel, avg } of result) {
        console.log(`- ${titel}: ${avg.toFixed(2)} â‚¬`);
    }


    // n) alle Paare von Kursleitern, die denselben Kurs halten, und den entsprechenden Kurstiteln.
    // Geben Sie jedes Paar nur einmal aus
    /**
     * @old-relational-table Fuehrt_Durch, Kursleiter, Kurs
     * @collections angebote, angebote/{PersNr}/kursleiter (Sub-Collection aus angebote)
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *       SELECT kl1.Name, kl2.Name, k.Titel
     *       FROM Fuehrt_Durch fd1
     *       JOIN Fuehrt_Durch fd2 ON fd1.KursNr = fd2.KursNr AND fd1.PersNr < fd2.PersNr
     *       JOIN Kursleiter kl1 ON fd1.PersNr = kl1.PersNr
     *       JOIN Kursleiter kl2 ON fd2.PersNr = kl2.PersNr
     *       JOIN Kurs k ON fd1.KursNr = k.KursNr;
     *   ğŸ”¹ In Firestore:
     *       Alle `angebote`-Dokumente laden.
     *       Pro KursNr alle darin vorkommenden Kursleiter (Ã¼ber mehrere Angebote hinweg) sammeln.
     *       Sobald mindestens zwei Kursleiter fÃ¼r denselben Kurs vorhanden sind, alle eindeutigen Paare bilden
     *       und mit dem redundanten `KursTitel` direkt ausgeben.
     *
     * @difference-to-sql
     *   Kein Self-Join mÃ¶glich â€“ Paare mÃ¼ssen im Client konstruiert werden.
     *   Dank Redundanz des Kurstitels in 'angebote' konnten die zusÃ¤tzlichen Abfragen verringert werden.
     */
    console.log('\nğŸ‘©â€ğŸ« Kursleiter-Paare fÃ¼r denselben Kurs:');

    // Kursleiter je KursNr sammeln
    const kursleiterProKurs: Record<string, Map<number, string>> = {}; // KursNr â†’ Map<PersNr, Name>
    const kursTitelMap2 = new Map<string, string>();

    const angeboteSnapshot7 = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
    for (const angebot of angeboteSnapshot7.docs) {
        const angebotData = angebot.data();
        const kursNr = angebotData.KursNr;
        const titel = angebotData.KursTitel ?? kursNr;
        kursTitelMap2.set(kursNr, titel);

        // Sub-Collection "kursleiter" lesen
        const leiterSnap = await angebot.ref.collection('kursleiter').withConverter(createConverter<Kursleiter>()).get();

        for (const doc of leiterSnap.docs) {
            const { Name } = doc.data();

            if (!kursleiterProKurs[kursNr]) {
                kursleiterProKurs[kursNr] = new Map();
            }

            kursleiterProKurs[kursNr].set(Number(doc.id), Name); // Duplikate werden durch Map automatisch vermieden
        }
    }

    // Paare bilden
    for (const [kursNr, leiterMap] of Object.entries(kursleiterProKurs)) {
        const titel = kursTitelMap2.get(kursNr) ?? kursNr;
        const leiter = Array.from(leiterMap.entries()); // [PersNr, Name]

        if (leiter.length < 2) continue;

        for (let i = 0; i < leiter.length - 1; i++) {
            for (let j = i + 1; j < leiter.length; j++) {
                const name1 = leiter[i][1];
                const name2 = leiter[j][1];
                console.log(`- ${titel}: ${name1} & ${name2}`);
            }
        }
    }


    console.log('\nâœ… Fertig.');
}

#### Ausgabe der Read Queries:

ğŸ“– Aufgabe 4: Read Queries

ğŸ“ Orte: [ 'Wedel', 'Augsburg', 'Mindelheim', 'Ulm', 'Muenchen' ]

ğŸ‘¥ Teilnehmer aus Augsburg:
- Huber, Chr.
- Kircher, B.
- Karstens, L.

ğŸ‘©â€ğŸ« Kursleiter (Gehalt 3000â‚¬-4000â‚¬):
- Mueller, K.: 3400.8â‚¬
- Schulze, H.: 3890.2â‚¬

ğŸ“š Kurstitel mit Datum und Ort:
- Grundlagen I: 13.10.2023 in Wedel
- Grundlagen II: 1.12.2023 in Augsburg
- Datenbanken: 27.3.2023 in Mindelheim
- C-Programmierung: 28.5.2023 in Augsburg
- Grundlagen I: 24.11.2023 in Ulm
- Grundlagen II: 15.2.2023 in Muenchen
- Datenbanken: 23.4.2023 in Muenchen
- C-Programmierung: 1.7.2023 in Augsburg
- Datenbanken: 29.5.2023 in Ulm

ğŸ“š Kurstitel mit Datum, Ort und Kursleiter:
- Grundlagen I: 13.10.2023, in Wedel, Kursleiter: Huber, L.
- Grundlagen II: 1.12.2023, in Augsburg, Kursleiter: Mueller, K.
- Datenbanken: 27.3.2023, in Mindelheim, Kursleiter: Schulze, H.
- C-Programmierung: 28.5.2023, in Augsburg, Kursleiter: Meier, I.
- Grundlagen I: 24.11.2023, in Ulm, Kursleiter: Huber, L.
- Grundlagen II: 15.2.2023, in Muenchen, Kursleiter: Schulze, H.
- Datenbanken: 23.4.2023, in Muenchen, Kursleiter: Schulze, H.
- C-Programmierung: 1.7.2023, in Augsburg, Kursleiter: Meier, I.
- Datenbanken: 29.5.2023, in Ulm, Kursleiter: Schulze, H.

ğŸ“š Kurstitel mit Voraussetzungen:
Kurs                     Voraussetzungen
C-Programmierung         Grundlagen I, Grundlagen II
Datenbanken              Grundlagen I, Grundlagen II, C-Programmierung
Grundlagen I             NULL
Grundlagen II            NULL

ğŸ‘¥ Teilnehmer am eigenen Wohnort:
- Kircher, B.: Augsburg

ğŸ“š Kursangebote ohne Teilnehmer:
- Grundlagen II, Angebot 1_G10
- Grundlagen II, Angebot 2_G10
- Datenbanken, Angebot 3_I09

ğŸ“š Kurse mit mindestens 2 Teilnehmern (alle Angebote zusammengefasst):
- Grundlagen I: 2 Teilnehmer
- C-Programmierung: 5 Teilnehmer
- Datenbanken: 6 Teilnehmer

ğŸ‘¥ Alle Meier:
- Teilnehmer: Meier, K.
- Teilnehmer: Meier, W.
- Kursleiter: Meier, I.

ğŸ“š Kurstitel mit Anzahl der Angebote:
- C-Programmierung: 2 Angebote
- Datenbanken: 3 Angebote
- Grundlagen I: 2 Angebote
- Grundlagen II: 2 Angebote

ğŸ“šKurse mit mindestens 2 Voraussetzungen (absteigend sortiert):
- Datenbanken: 3 Voraussetzungen
- C-Programmierung: 2 Voraussetzungen

ğŸ“š Durchschnittliches Gehalt der Kursleiter pro Kurs (aufsteigend):
- Grundlagen II: 3645.50 â‚¬
- Datenbanken: 3890.20 â‚¬
- Grundlagen I: 4200.10 â‚¬
- C-Programmierung: 4300.50 â‚¬

ğŸ‘©â€ğŸ« Kursleiter-Paare fÃ¼r denselben Kurs:
- Grundlagen II: Mueller, K. & Schulze, H.

âœ… Fertig.

#### Aufgabe 5: Update Queries:

async function aufgabe5() {
    console.log('â™»ï¸ Aufgabe 5: Update Queries\n');

    // a) Alle Angebote vom Jahr 2023 auf 2024 aktualisieren
    /**
     * @old-relational-table Angebot
     * @collection angebote
     *
     * @logic
     *   ğŸ”¸ In SQL einfache UPDATE-Anweisung:
     *          UPDATE Angebot SET Datum = DATE + INTERVAL '1 year' WHERE EXTRACT(YEAR FROM Datum) = 2023;
     *   ğŸ”¹ In Firestore:
     *          - laden aller Angebote, bei welchen der Timestamp im Jahr 2023 liegt
     *          - abÃ¤ndern des Timestamps
     *          - anschlieÃŸendes updaten in der Datenbank
     *
     * @difference-to-sql
     *    Laden aller Angebote, welche im Jahr 2023 stattfinden und anschlieÃŸendes manuelles AbÃ¤ndern des Datums, sowie speichern in der Datenbank.
     *    In SQL erfolgt dies automatisch mit der Update-Anweisung
     */
    const startOf2023 = Timestamp.fromDate(new Date("2023-01-01T00:00:00Z"));
    const startOf2024 = Timestamp.fromDate(new Date("2024-01-01T00:00:00Z"));

    const angebote2023 = await db.collection('angebote')
        .withConverter(createConverter<Angebot>())
        .where('Datum', '>=', startOf2023)
        .where('Datum', '<', startOf2024)
        .get();
    for (const doc of angebote2023.docs) {
        const angebot = doc.data();
        const date = angebot.Datum.toDate();
        const neuesDatum = Timestamp.fromDate(new Date(date.setFullYear(2024)));
        await doc.ref.update({Datum: neuesDatum});
        console.log(`ğŸ”„ Angebot ${doc.id} Datum aktualisiert auf ${neuesDatum.toDate().toLocaleDateString()}`);
    }

    // b) Alle Angebote von "Wedel" nach "Augsburg"
    /**
     * @old-relational-table Angebot
     * @collection angebote
     *
     * @logic
     *   ğŸ”¸ In SQL einfache UPDATE-Anweisung:
     *          UPDATE Angebot SET Ort = 'Augsburg' WHERE Ort = 'Wedel';
     *
     *   ğŸ”¹ In Firestore:
     *          - laden aller Angebote mit Ort == 'Wedel'
     *          - iterieren Ã¼ber alle erhaltenen Angebote mit Updaten des Orts in der Datenbank
     *
     * @difference-to-sql
     *    Manuelles Updaten der Dokumente.
     */
    const angeboteWedel = await db.collection('angebote')
        .withConverter(createConverter<Angebot>())
        .where('Ort', '==', 'Wedel').get();

    for (const doc of angeboteWedel.docs) {
        await doc.ref.update({ Ort: 'Augsburg' });
        console.log(`ğŸ“ Angebot ${doc.id} von Wedel nach Augsburg verschoben.`);
    }


    /**
     * Sobald man update-Anfragen hat, die mehrere Collections betreffen, bei denen mehrere Daten redundant gehalten werden,
     * dann sollte man in Betracht ziehen, eine Transaktion oder Batch-Operation zu verwenden. Diese Vorgehensweise
     * wird beispielhaft bei den delete-Queries als Kommentar am Ende der Datei beschrieben.
     */


    console.log('\nâœ… Fertig.');
}

#### Ausgabe der Update Queries:

â™»ï¸ Aufgabe 5: Update Queries

ğŸ”„ Angebot 2_G10 Datum aktualisiert auf 15.2.2024
ğŸ”„ Angebot 1_I09 Datum aktualisiert auf 27.3.2024
ğŸ”„ Angebot 2_I09 Datum aktualisiert auf 23.4.2024
ğŸ”„ Angebot 1_P13 Datum aktualisiert auf 28.5.2024
ğŸ”„ Angebot 3_I09 Datum aktualisiert auf 29.5.2024
ğŸ”„ Angebot 2_P13 Datum aktualisiert auf 1.7.2024
ğŸ”„ Angebot 1_G08 Datum aktualisiert auf 13.10.2024
ğŸ”„ Angebot 2_G08 Datum aktualisiert auf 24.11.2024
ğŸ”„ Angebot 1_G10 Datum aktualisiert auf 1.12.2024
ğŸ“ Angebot 1_G08 von Wedel nach Augsburg verschoben.

âœ… Fertig.

#### Aufgabe 6: Delete Queries:

async function aufgabe6() {
    console.log('ğŸ—‘ï¸ Aufgabe 6: Delete Queries\n');

    // a) LÃ¶sche die Kursliteratur fÃ¼r "C-Programmierung"
    /**
     * @old-relational-table Kurs, KursLiteratur
     * @collections kurse, kurse/{KursNr}/kursliteratur (Sub-Collection aus kurse)
     *
     * @id
     *   In "kurse": Dokumenten-ID = KursNr (z. B.: "P13")
     *   In Sub-Collection "kursliteratur": Dokumenten-ID = "standard"
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *      Ermittle KursNr fÃ¼r den Kurs mit Titel "C-Programmierung"
     *          SELECT KursNr FROM Kurs WHERE Titel = 'C-Programmierung';
     *      LÃ¶sche die zugehÃ¶rige Literatur:
     *          DELETE FROM KursLiteratur WHERE KursNr = 'P13';
     *
     *   ğŸ”¹ In Firestore:
     *      1. Suche im Collection "kurse" nach einem Dokument mit Feld `Titel` == "C-Programmierung".
     *      2. Greife auf das Dokument `kursliteratur/standard` innerhalb des gefundenen Kurses zu.
     *      3. LÃ¶sche das Dokument `standard` in der Sub-Collection `kursliteratur`.
     *
     * @risk
     * Es gibt keine automatische PrÃ¼fung oder Foreign-Key-Beziehungen:
     * - Die Literatur kann gelÃ¶scht werden, auch wenn sie noch z. B. in einem Angebot verwendet wird.
     * - Entwickler mÃ¼ssen selbst fÃ¼r Konsistenz sorgen.
     *
     * @difference-to-sql
     * In SQL genÃ¼gt ein einfacher `DELETE` mit WHERE-Klausel Ã¼ber `KursNr`.
     * In Firestore ist eine Suche nach dem Titel erforderlich,
     * gefolgt vom Zugriff auf die Sub-Collection `kursliteratur`, um das "standard"-Dokument zu lÃ¶schen.
     */
    const kursSnapshot = await db.collection('kurse')
        .withConverter(createConverter<Kurs>())
        .where('Titel', '==', 'C-Programmierung').get();

    if (kursSnapshot.empty) {
        console.log('âŒ Kurs "C-Programmierung" nicht gefunden.');
    } else {
        const kursDocRef = kursSnapshot.docs[0].ref;
        const litRef = kursDocRef.collection('kursliteratur').doc('standard');
        await litRef.delete();
        console.log('ğŸ“š Kursliteratur fÃ¼r "C-Programmierung" gelÃ¶scht.');
    }

    // b) LÃ¶sche alle Kursangebote mit weniger als 2 Teilnehmern
    /**
     * @old-relational-table Nimmt_teil, Angebot, GebÃ¼hren
     * @collections angebote, teilnehmer, teilnehmer/{TnNr}/teilnahmen (Sub-Collection aus teilnehmer)
     *
     * @id
     *   In "angebote": Dokumenten-ID = AngNr_KursNr (z.B.: "2_P13")
     *   In "teilnehmer": Dokumenten-ID = TnNr
     *   In Sub-Collection "teilnahmen": Feld AngNr_KursNr referenziert Angebot
     *
     * @logic
     *   ğŸ”¸ In SQL:
     *      Finde Angebote mit weniger als 2 Teilnehmern:
     *             SELECT A.AngNr
     *             FROM Angebot A
     *             JOIN Nimmt_teil NT ON A.AngNr = NT.AngNr
     *             GROUP BY A.AngNr
     *             HAVING COUNT(*) < 2;
     *
     *      LÃ¶sche die EintrÃ¤ge in "Nimmt_teil" und "Gebuehren":
     *             DELETE FROM Nimmt_teil WHERE AngNr = <zu lÃ¶schende AngNr>;
     *             DELETE FROM Gebuehren WHERE AngNr = <zu lÃ¶schende AngNr>;
     *
     *      LÃ¶sche das Angebot:
     *             DELETE FROM Angebot WHERE AngNr = <zu lÃ¶schende AngNr>;
     *
     *   ğŸ”¹ In Firestore:
     *       1. Lade alle Dokumente aus "angebote" und "teilnehmer".
     *       2. ZÃ¤hle pro Angebot, wie viele Teilnehmer eine Teilnahme mit der entsprechenden AngNr_KursNr haben.
     *       3. Wenn die Anzahl < 2, lÃ¶sche:
     *                - das Angebot selbst
     *                - alle zugehÃ¶rigen "teilnahmen"
     * @risk
     * In Firestore gibt es keine referenzielle IntegritÃ¤t:
     *      - Teilnahmen, die auf nicht existierende Angebote zeigen, mÃ¼ssen manuell bereinigt werden.
     *      - Ein versehentliches LÃ¶schen kann nicht durch Constraints verhindert werden.
     *      - Entwickler mÃ¼ssen sicherstellen, dass keine "verwaisten" Dokumente entstehen.
     *      - Ohne Transaktionen oder Batch-Operationen kann es zu Inkonsistenzen beim LÃ¶schen kommen
     *
     * @difference-to-sql
     * - In Firestore gibt es KEINE Kombination aus JOIN + WHERE + DELETE + GROUP BY oder CASCADEN-Delete.
     * - In SQL kann man JOINS und Bedingungen direkt im DELETE kombinieren.
     * - In Firestore mÃ¼ssen Dokumente einzeln geladen und verglichen werden.
     * - ZÃ¤hlung und Selektion mÃ¼ssen manuell in der Applikation durchgefÃ¼hrt werden.
     * - Zudem erfolgt die Navigation zu "teilnahmen" Ã¼ber die Sub-Collection jedes Teilnehmers.
     */
      const angeboteSnapshot = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
      const teilnehmerSnapshot = await db.collection('teilnehmer').withConverter(createConverter<Teilnehmer>()).get();

      const angebotTeilnahmeZaehler: Record<string, number> = {};
      const zuLoeschendeAngebote: string[] = [];

      // ZÃ¤hle die Teilnehmer pro Angebot
      for (const teilnehmerDoc of teilnehmerSnapshot.docs) {
          const teilnahmenSnap = await teilnehmerDoc.ref.collection('teilnahmen').get();
          for (const t of teilnahmenSnap.docs) {
              const { AngNr } = t.data() as Teilnahme;
              angebotTeilnahmeZaehler[AngNr] = (angebotTeilnahmeZaehler[AngNr] || 0) + 1;
          }
      }

      // LÃ¶sche Angebote mit < 2 Teilnehmern und merke dir die AngNr_KursNr
      for (const angebotDoc of angeboteSnapshot.docs) {
          const angebotId = angebotDoc.id;
          const teilnehmerAnzahl = angebotTeilnahmeZaehler[angebotId] || 0;
          if (teilnehmerAnzahl < 2) {
              await angebotDoc.ref.collection('kursleiter').get().then(kursleiterSnap => {
                  // LÃ¶sche alle Kursleiter fÃ¼r dieses Angebot
                  const deletePromises = kursleiterSnap.docs.map(k => k.ref.delete());
                  return Promise.all(deletePromises);
              });
              await angebotDoc.ref.delete();
              zuLoeschendeAngebote.push(angebotId);
              console.log(`ğŸ—‘ï¸ Angebot ${angebotId} gelÃ¶scht (nur ${teilnehmerAnzahl} Teilnehmer).`);
          }
      }

      // LÃ¶sche zugehÃ¶rige Teilnahmen in allen Teilnehmer-Dokumenten
      for (const teilnehmerDoc of teilnehmerSnapshot.docs) {
          const teilnahmenSnap = await teilnehmerDoc.ref.collection('teilnahmen').get();
          for (const t of teilnahmenSnap.docs) {
              const { AngNr } = t.data() as Teilnahme;
              if (zuLoeschendeAngebote.includes(AngNr)) {
                  await t.ref.delete();
                  console.log(`ğŸ—‘ï¸ Teilnahme ${t.id} von Teilnehmer ${teilnehmerDoc.id} gelÃ¶scht (bezog sich auf Angebot ${AngNr}).`);
              }
          }
      }


    /**
     * Hinweis: Zusatz zu Aufgabe b - LÃ¶schen von Angeboten mit <2 Teilnehmern
     * Transaktion und Batch-Operationen fÃ¼r konsistente LÃ¶schvorgÃ¤nge bei groÃŸen Datenmengen
     *
     * const angeboteSnapshot = await db.collection('angebote').withConverter(createConverter<Angebot>()).get();
     * const teilnehmerSnapshot = await db.collection('teilnehmer').withConverter(createConverter<Teilnehmer>()).get();
     *
     * ZÃ¤hle die Teilnehmer pro Angebot
     *  const angebotTeilnahmeZaehler: Record<string, number> = {};
     *  for (const teilnehmerDoc of teilnehmerSnapshot.docs) {
     *  const teilnahmenSnap = await teilnehmerDoc.ref.collection('teilnahmen').get();
     *  for (const t of teilnahmenSnap.docs) {
     *      const { AngNr } = t.data() as Teilnahme;
     *      angebotTeilnahmeZaehler[AngNr] = (angebotTeilnahmeZaehler[AngNr] || 0) + 1;
     *      }
     *  }
     *
     *  const zuLoeschendeAngebote: string[] = [];
     *
     *  await db.runTransaction(async (transaction) => {
     *      for (const angebotDoc of angeboteSnapshot.docs) {
     *          const angebotId = angebotDoc.id;
     *          const teilnehmerAnzahl = angebotTeilnahmeZaehler[angebotId] || 0;
     *
     *          if (teilnehmerAnzahl < 2) {
     *              const kursleiterSnap = await angebotDoc.ref.collection('kursleiter').get();
     *              kursleiterSnap.docs.forEach(kursleiterDoc => {
     *                  transaction.delete(kursleiterDoc.ref);
     *              });
     *
     *              transaction.delete(angebotDoc.ref);
     *              zuLoeschendeAngebote.push(angebotId);
     *
     *              console.log(`ğŸ—‘ï¸ Angebot ${angebotId} gelÃ¶scht in Transaktion (nur ${teilnehmerAnzahl} Teilnehmer).`);
     *          }
     *      }
     *  });
     *
     *  BATCH: LÃ¶sche verknÃ¼pfte Teilnahmen
     *  let batch = db.batch();
     *  let opCount = 0;
     *  const MAX_BATCH_OPS = 490;
     *
     *  for (const teilnehmerDoc of teilnehmerSnapshot.docs) {
     *      const teilnahmenSnap = await teilnehmerDoc.ref.collection('teilnahmen').get();
     *      for (const teilnahmeDoc of teilnahmenSnap.docs) {
     *          const { AngNr } = teilnahmeDoc.data() as Teilnahme;
     *          if (zuLoeschendeAngebote.includes(AngNr)) {
     *              batch.delete(teilnahmeDoc.ref);
     *              console.log(`ğŸ—‘ï¸ Teilnahme ${teilnahmeDoc.id} gelÃ¶scht (bezog sich auf Angebot ${AngNr}).`);
     *
     *              opCount++;
     *              if (opCount >= MAX_BATCH_OPS) {
     *                  await batch.commit();
     *                  batch = db.batch();
     *                  opCount = 0;
     *             }
     *          }
     *    }
     *  }
     *
     *  if (opCount > 0) {
     *      await batch.commit();
     *  }
     */


    console.log('\nâœ… LÃ¶schvorgÃ¤nge abgeschlossen.');
}

#### Ausgabe der Delete Queries:

ğŸ—‘ï¸ Aufgabe 6: Delete Queries

ğŸ“š Kursliteratur fÃ¼r "C-Programmierung" gelÃ¶scht.
ğŸ—‘ï¸ Angebot 1_G08 gelÃ¶scht (nur 1 Teilnehmer).
ğŸ—‘ï¸ Angebot 1_G10 gelÃ¶scht (nur 0 Teilnehmer).
ğŸ—‘ï¸ Angebot 2_G08 gelÃ¶scht (nur 1 Teilnehmer).
ğŸ—‘ï¸ Angebot 2_G10 gelÃ¶scht (nur 0 Teilnehmer).
ğŸ—‘ï¸ Angebot 2_I09 gelÃ¶scht (nur 1 Teilnehmer).
ğŸ—‘ï¸ Angebot 3_I09 gelÃ¶scht (nur 0 Teilnehmer).
ğŸ—‘ï¸ Teilnahme teilnahme_0 von Teilnehmer 143 gelÃ¶scht (bezog sich auf Angebot 2_G08).
ğŸ—‘ï¸ Teilnahme teilnahme_0 von Teilnehmer 145 gelÃ¶scht (bezog sich auf Angebot 1_G08).
ğŸ—‘ï¸ Teilnahme teilnahme_0 von Teilnehmer 187 gelÃ¶scht (bezog sich auf Angebot 2_I09).

âœ… LÃ¶schvorgÃ¤nge abgeschlossen.
